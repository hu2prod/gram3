# WARNING!!! AUTOGENERATED with gen_tc.coffee
module = @
{
  Tokenizer
  Token_parser
} = require './tokenizer'
# ###################################################################################################
#    tokenizer
# ###################################################################################################
tokenizer = new Tokenizer
tokenizer.parser_list.push (new Token_parser 'hash_id', /^\#[_a-z0-9]+/i )
tokenizer.parser_list.push (new Token_parser 'option',  /^\?/ )
tokenizer.parser_list.push (new Token_parser 'plus',    /^\+/ )
tokenizer.parser_list.push (new Token_parser 'star',    /^\*/ )
tokenizer.parser_list.push (new Token_parser 'bra_op',  /^\(/ )
tokenizer.parser_list.push (new Token_parser 'bra_cl',  /^\)/ )
tokenizer.parser_list.push (new Token_parser 'or',      /^\|/ )
tokenizer.parser_list.push (new Token_parser 'q_token', /^\'[^']*\'/ )
tokenizer.parser_list.push (new Token_parser 'token',   /^[_a-z0-9]+/ )
tokenizer.parser_list.push (new Token_parser 'escape_token', /^\\\S/ )


# ###################################################################################################
#    gram
# ###################################################################################################

require 'fy'
{Node} = require "./index"
class Hypothesis
  a : 0
  b : 0
  ret_hash : ''
  list : []
  _is_new : false
  constructor : ()->
    @list = []
  
  clone : ()->
    ret = new Hypothesis
    ret.a = @a
    ret.b = @b
    ret.ret_hash = @ret_hash
    ret.list = @list.clone()
    ret._is_new = @_is_new
    ret
  
  push   : (proxy_node)->
    @list.push proxy_node
    @b = proxy_node.token.b
    if @list.length == 1
      @_is_new = proxy_node.token._is_new
    return
  

class @Parser
  cache     : []
  drop      : []
  constructor : ()->
  
  go : (token_list_list)->
    @cache = []
    @drop  = []
    for token_list,idx in token_list_list
      stub = {}
      for token in token_list
        token.a = idx
        token.b = idx+1
        stub[token.mx_hash.hash_key] = [token]
        stub['*'] = [token]
      @cache.push stub
      @drop.push {}
    
    list = @token_stmt(0)
    max_token = token_list_list.length
    
    filter_list = []
    for v in list
      filter_list.push v if v.b == max_token
    # Прим. А все ошибки, почему не прошло ... смотрим и анализируем @cache и @drop
    filter_list
  
  token_atom : (start_pos)->
    if start_pos >= @cache.length
      ### !pragma coverage-skip-block ###
      return []
    return ret if ret = @cache[start_pos]["atom"]
    
    node_list = []
    node_list.append @rule_Hq_token_ultEconst__u1 start_pos
    node_list.append @rule_Htoken_ultEconst__u2 start_pos
    node_list.append @rule_Hescape_token_ultEconst__u3 start_pos
    node_list.append @rule_Hhash_id_ultEref__u4 start_pos
    node_list.append @rule_Hbra_op_Hstmt_Hbra_cl_ultEbra__u10 start_pos
    
    FAcache = @cache[start_pos]["atom"] = node_list
    
    return FAcache
  
  token_q_token : (start_pos)->
    if start_pos >= @cache.length
      ### !pragma coverage-skip-block ###
      return []
    return ret if ret = @cache[start_pos]["q_token"]
    
    node_list = []
    
    
    FAcache = @cache[start_pos]["q_token"] = node_list
    
    return FAcache
  
  token_token : (start_pos)->
    if start_pos >= @cache.length
      ### !pragma coverage-skip-block ###
      return []
    return ret if ret = @cache[start_pos]["token"]
    
    node_list = []
    
    
    FAcache = @cache[start_pos]["token"] = node_list
    
    return FAcache
  
  token_escape_token : (start_pos)->
    if start_pos >= @cache.length
      ### !pragma coverage-skip-block ###
      return []
    return ret if ret = @cache[start_pos]["escape_token"]
    
    node_list = []
    
    
    FAcache = @cache[start_pos]["escape_token"] = node_list
    
    return FAcache
  
  token_hash_id : (start_pos)->
    if start_pos >= @cache.length
      ### !pragma coverage-skip-block ###
      return []
    return ret if ret = @cache[start_pos]["hash_id"]
    
    node_list = []
    
    
    FAcache = @cache[start_pos]["hash_id"] = node_list
    
    return FAcache
  
  token_expr : (start_pos)->
    if start_pos >= @cache.length
      ### !pragma coverage-skip-block ###
      return []
    return ret if ret = @cache[start_pos]["expr"]
    
    node_list = []
    node_list.append @rule_Hatom_ultEpass__u5 start_pos
    node_list.append @rule_Hatom_Hor_Hexpr_ultEor__u6 start_pos
    
    FAcache = @cache[start_pos]["expr"] = node_list
    
    return FAcache
  
  token_or : (start_pos)->
    if start_pos >= @cache.length
      ### !pragma coverage-skip-block ###
      return []
    return ret if ret = @cache[start_pos]["or"]
    
    node_list = []
    
    
    FAcache = @cache[start_pos]["or"] = node_list
    
    return FAcache
  
  token_stmt : (start_pos)->
    if start_pos >= @cache.length
      ### !pragma coverage-skip-block ###
      return []
    return ret if ret = @cache[start_pos]["stmt"]
    
    node_list = []
    node_list.append @rule_Hatom_Hoption_ultEoption__u7 start_pos
    node_list.append @rule_Hatom_Hplus_ultEplus__u8 start_pos
    node_list.append @rule_Hatom_Hstar_ultEstar__u9 start_pos
    node_list.append @rule_Hexpr_ultEpass__u11 start_pos
    node_list.append @rule_Hexpr_Hstmt_ultEjoin__u12 start_pos
    
    FAcache = @cache[start_pos]["stmt"] = node_list
    
    return FAcache
  
  token_option : (start_pos)->
    if start_pos >= @cache.length
      ### !pragma coverage-skip-block ###
      return []
    return ret if ret = @cache[start_pos]["option"]
    
    node_list = []
    
    
    FAcache = @cache[start_pos]["option"] = node_list
    
    return FAcache
  
  token_plus : (start_pos)->
    if start_pos >= @cache.length
      ### !pragma coverage-skip-block ###
      return []
    return ret if ret = @cache[start_pos]["plus"]
    
    node_list = []
    
    
    FAcache = @cache[start_pos]["plus"] = node_list
    
    return FAcache
  
  token_star : (start_pos)->
    if start_pos >= @cache.length
      ### !pragma coverage-skip-block ###
      return []
    return ret if ret = @cache[start_pos]["star"]
    
    node_list = []
    
    
    FAcache = @cache[start_pos]["star"] = node_list
    
    return FAcache
  
  token_bra_op : (start_pos)->
    if start_pos >= @cache.length
      ### !pragma coverage-skip-block ###
      return []
    return ret if ret = @cache[start_pos]["bra_op"]
    
    node_list = []
    
    
    FAcache = @cache[start_pos]["bra_op"] = node_list
    
    return FAcache
  
  token_bra_cl : (start_pos)->
    if start_pos >= @cache.length
      ### !pragma coverage-skip-block ###
      return []
    return ret if ret = @cache[start_pos]["bra_cl"]
    
    node_list = []
    
    
    FAcache = @cache[start_pos]["bra_cl"] = node_list
    
    return FAcache
  
  # rule("atom", "#q_token")                          .mx("ult=const")
  rule_Hq_token_ultEconst__u1 : (start_pos, only_new = false)->
    group_idx = 1
    
    zero_hyp = new Hypothesis
    zero_hyp.ret_hash = "atom"
    zero_hyp.a = start_pos
    zero_hyp.b = start_pos
    hyp_list = [zero_hyp.clone()]
    
    prev_hyp_list = hyp_list
    hyp_list = []
    for hyp in prev_hyp_list
      for append_me in @token_q_token hyp.b
        hyp_add = hyp.clone()
        hyp_add.push {
          token : append_me
          label : 'TODO_tok_pos'
        }
        hyp_list.push hyp_add
    
    
    node_list = []
    for hyp in hyp_list
      
      node = new Node
      node.mx_hash.rule = "rule_Hq_token_ultEconst__u1"
      vv_list = []
      for obj in hyp.list
        # TODO obj.label -> hash_pos_idx
        node.value_array.push obj.token
        vv_list.push obj.token.value_view or obj.token.value
      node.value_view = vv_list.join ' '
      
      arg_list = node.value_array
      
      
      mx_hash_stub = node.mx_hash
      mx_hash_stub.hash_key = "atom"
      mx_hash_stub["ult"] = "const"
      
      node.a = node.value_array[0].a
      node.b = node.value_array.last().b
      
      node_list.push node
    
    return node_list
  
  # rule("atom", "#token")                            .mx("ult=const")
  rule_Htoken_ultEconst__u2 : (start_pos, only_new = false)->
    group_idx = 1
    
    zero_hyp = new Hypothesis
    zero_hyp.ret_hash = "atom"
    zero_hyp.a = start_pos
    zero_hyp.b = start_pos
    hyp_list = [zero_hyp.clone()]
    
    prev_hyp_list = hyp_list
    hyp_list = []
    for hyp in prev_hyp_list
      for append_me in @token_token hyp.b
        hyp_add = hyp.clone()
        hyp_add.push {
          token : append_me
          label : 'TODO_tok_pos'
        }
        hyp_list.push hyp_add
    
    
    node_list = []
    for hyp in hyp_list
      
      node = new Node
      node.mx_hash.rule = "rule_Htoken_ultEconst__u2"
      vv_list = []
      for obj in hyp.list
        # TODO obj.label -> hash_pos_idx
        node.value_array.push obj.token
        vv_list.push obj.token.value_view or obj.token.value
      node.value_view = vv_list.join ' '
      
      arg_list = node.value_array
      
      
      mx_hash_stub = node.mx_hash
      mx_hash_stub.hash_key = "atom"
      mx_hash_stub["ult"] = "const"
      
      node.a = node.value_array[0].a
      node.b = node.value_array.last().b
      
      node_list.push node
    
    return node_list
  
  # rule("atom", "#escape_token")                     .mx("ult=const")
  rule_Hescape_token_ultEconst__u3 : (start_pos, only_new = false)->
    group_idx = 1
    
    zero_hyp = new Hypothesis
    zero_hyp.ret_hash = "atom"
    zero_hyp.a = start_pos
    zero_hyp.b = start_pos
    hyp_list = [zero_hyp.clone()]
    
    prev_hyp_list = hyp_list
    hyp_list = []
    for hyp in prev_hyp_list
      for append_me in @token_escape_token hyp.b
        hyp_add = hyp.clone()
        hyp_add.push {
          token : append_me
          label : 'TODO_tok_pos'
        }
        hyp_list.push hyp_add
    
    
    node_list = []
    for hyp in hyp_list
      
      node = new Node
      node.mx_hash.rule = "rule_Hescape_token_ultEconst__u3"
      vv_list = []
      for obj in hyp.list
        # TODO obj.label -> hash_pos_idx
        node.value_array.push obj.token
        vv_list.push obj.token.value_view or obj.token.value
      node.value_view = vv_list.join ' '
      
      arg_list = node.value_array
      
      
      mx_hash_stub = node.mx_hash
      mx_hash_stub.hash_key = "atom"
      mx_hash_stub["ult"] = "const"
      
      node.a = node.value_array[0].a
      node.b = node.value_array.last().b
      
      node_list.push node
    
    return node_list
  
  # rule("atom", "#hash_id")                          .mx("ult=ref")
  rule_Hhash_id_ultEref__u4 : (start_pos, only_new = false)->
    group_idx = 1
    
    zero_hyp = new Hypothesis
    zero_hyp.ret_hash = "atom"
    zero_hyp.a = start_pos
    zero_hyp.b = start_pos
    hyp_list = [zero_hyp.clone()]
    
    prev_hyp_list = hyp_list
    hyp_list = []
    for hyp in prev_hyp_list
      for append_me in @token_hash_id hyp.b
        hyp_add = hyp.clone()
        hyp_add.push {
          token : append_me
          label : 'TODO_tok_pos'
        }
        hyp_list.push hyp_add
    
    
    node_list = []
    for hyp in hyp_list
      
      node = new Node
      node.mx_hash.rule = "rule_Hhash_id_ultEref__u4"
      vv_list = []
      for obj in hyp.list
        # TODO obj.label -> hash_pos_idx
        node.value_array.push obj.token
        vv_list.push obj.token.value_view or obj.token.value
      node.value_view = vv_list.join ' '
      
      arg_list = node.value_array
      
      
      mx_hash_stub = node.mx_hash
      mx_hash_stub.hash_key = "atom"
      mx_hash_stub["ult"] = "ref"
      
      node.a = node.value_array[0].a
      node.b = node.value_array.last().b
      
      node_list.push node
    
    return node_list
  
  # rule("atom", "#bra_op #stmt #bra_cl")             .mx("ult=bra")
  rule_Hbra_op_Hstmt_Hbra_cl_ultEbra__u10 : (start_pos, only_new = false)->
    group_idx = 1
    
    zero_hyp = new Hypothesis
    zero_hyp.ret_hash = "atom"
    zero_hyp.a = start_pos
    zero_hyp.b = start_pos
    hyp_list = [zero_hyp.clone()]
    
    prev_hyp_list = hyp_list
    hyp_list = []
    for hyp in prev_hyp_list
      for append_me in @token_bra_op hyp.b
        hyp_add = hyp.clone()
        hyp_add.push {
          token : append_me
          label : 'TODO_tok_pos'
        }
        hyp_list.push hyp_add
    
    prev_hyp_list = hyp_list
    hyp_list = []
    for hyp in prev_hyp_list
      for append_me in @token_stmt hyp.b
        hyp_add = hyp.clone()
        hyp_add.push {
          token : append_me
          label : 'TODO_tok_pos'
        }
        hyp_list.push hyp_add
    
    prev_hyp_list = hyp_list
    hyp_list = []
    for hyp in prev_hyp_list
      for append_me in @token_bra_cl hyp.b
        hyp_add = hyp.clone()
        hyp_add.push {
          token : append_me
          label : 'TODO_tok_pos'
        }
        hyp_list.push hyp_add
    
    
    node_list = []
    for hyp in hyp_list
      
      node = new Node
      node.mx_hash.rule = "rule_Hbra_op_Hstmt_Hbra_cl_ultEbra__u10"
      vv_list = []
      for obj in hyp.list
        # TODO obj.label -> hash_pos_idx
        node.value_array.push obj.token
        vv_list.push obj.token.value_view or obj.token.value
      node.value_view = vv_list.join ' '
      
      arg_list = node.value_array
      
      
      mx_hash_stub = node.mx_hash
      mx_hash_stub.hash_key = "atom"
      mx_hash_stub["ult"] = "bra"
      
      node.a = node.value_array[0].a
      node.b = node.value_array.last().b
      
      node_list.push node
    
    return node_list
  
  # rule("expr", "#atom")                             .mx("ult=pass")
  rule_Hatom_ultEpass__u5 : (start_pos, only_new = false)->
    group_idx = 1
    
    zero_hyp = new Hypothesis
    zero_hyp.ret_hash = "expr"
    zero_hyp.a = start_pos
    zero_hyp.b = start_pos
    hyp_list = [zero_hyp.clone()]
    
    prev_hyp_list = hyp_list
    hyp_list = []
    for hyp in prev_hyp_list
      for append_me in @token_atom hyp.b
        hyp_add = hyp.clone()
        hyp_add.push {
          token : append_me
          label : 'TODO_tok_pos'
        }
        hyp_list.push hyp_add
    
    
    node_list = []
    for hyp in hyp_list
      
      node = new Node
      node.mx_hash.rule = "rule_Hatom_ultEpass__u5"
      vv_list = []
      for obj in hyp.list
        # TODO obj.label -> hash_pos_idx
        node.value_array.push obj.token
        vv_list.push obj.token.value_view or obj.token.value
      node.value_view = vv_list.join ' '
      
      arg_list = node.value_array
      
      
      mx_hash_stub = node.mx_hash
      mx_hash_stub.hash_key = "expr"
      mx_hash_stub["ult"] = "pass"
      
      node.a = node.value_array[0].a
      node.b = node.value_array.last().b
      
      node_list.push node
    
    return node_list
  
  # rule("expr", "#atom #or #expr")                   .mx("ult=or")
  rule_Hatom_Hor_Hexpr_ultEor__u6 : (start_pos, only_new = false)->
    group_idx = 1
    
    zero_hyp = new Hypothesis
    zero_hyp.ret_hash = "expr"
    zero_hyp.a = start_pos
    zero_hyp.b = start_pos
    hyp_list = [zero_hyp.clone()]
    
    prev_hyp_list = hyp_list
    hyp_list = []
    for hyp in prev_hyp_list
      for append_me in @token_atom hyp.b
        hyp_add = hyp.clone()
        hyp_add.push {
          token : append_me
          label : 'TODO_tok_pos'
        }
        hyp_list.push hyp_add
    
    prev_hyp_list = hyp_list
    hyp_list = []
    for hyp in prev_hyp_list
      for append_me in @token_or hyp.b
        hyp_add = hyp.clone()
        hyp_add.push {
          token : append_me
          label : 'TODO_tok_pos'
        }
        hyp_list.push hyp_add
    
    prev_hyp_list = hyp_list
    hyp_list = []
    for hyp in prev_hyp_list
      for append_me in @token_expr hyp.b
        hyp_add = hyp.clone()
        hyp_add.push {
          token : append_me
          label : 'TODO_tok_pos'
        }
        hyp_list.push hyp_add
    
    
    node_list = []
    for hyp in hyp_list
      
      node = new Node
      node.mx_hash.rule = "rule_Hatom_Hor_Hexpr_ultEor__u6"
      vv_list = []
      for obj in hyp.list
        # TODO obj.label -> hash_pos_idx
        node.value_array.push obj.token
        vv_list.push obj.token.value_view or obj.token.value
      node.value_view = vv_list.join ' '
      
      arg_list = node.value_array
      
      
      mx_hash_stub = node.mx_hash
      mx_hash_stub.hash_key = "expr"
      mx_hash_stub["ult"] = "or"
      
      node.a = node.value_array[0].a
      node.b = node.value_array.last().b
      
      node_list.push node
    
    return node_list
  
  # rule("stmt", "#atom #option")                     .mx("ult=option")
  rule_Hatom_Hoption_ultEoption__u7 : (start_pos, only_new = false)->
    group_idx = 1
    
    zero_hyp = new Hypothesis
    zero_hyp.ret_hash = "stmt"
    zero_hyp.a = start_pos
    zero_hyp.b = start_pos
    hyp_list = [zero_hyp.clone()]
    
    prev_hyp_list = hyp_list
    hyp_list = []
    for hyp in prev_hyp_list
      for append_me in @token_atom hyp.b
        hyp_add = hyp.clone()
        hyp_add.push {
          token : append_me
          label : 'TODO_tok_pos'
        }
        hyp_list.push hyp_add
    
    prev_hyp_list = hyp_list
    hyp_list = []
    for hyp in prev_hyp_list
      for append_me in @token_option hyp.b
        hyp_add = hyp.clone()
        hyp_add.push {
          token : append_me
          label : 'TODO_tok_pos'
        }
        hyp_list.push hyp_add
    
    
    node_list = []
    for hyp in hyp_list
      
      node = new Node
      node.mx_hash.rule = "rule_Hatom_Hoption_ultEoption__u7"
      vv_list = []
      for obj in hyp.list
        # TODO obj.label -> hash_pos_idx
        node.value_array.push obj.token
        vv_list.push obj.token.value_view or obj.token.value
      node.value_view = vv_list.join ' '
      
      arg_list = node.value_array
      
      
      mx_hash_stub = node.mx_hash
      mx_hash_stub.hash_key = "stmt"
      mx_hash_stub["ult"] = "option"
      
      node.a = node.value_array[0].a
      node.b = node.value_array.last().b
      
      node_list.push node
    
    return node_list
  
  # rule("stmt", "#atom #plus")                       .mx("ult=plus")
  rule_Hatom_Hplus_ultEplus__u8 : (start_pos, only_new = false)->
    group_idx = 1
    
    zero_hyp = new Hypothesis
    zero_hyp.ret_hash = "stmt"
    zero_hyp.a = start_pos
    zero_hyp.b = start_pos
    hyp_list = [zero_hyp.clone()]
    
    prev_hyp_list = hyp_list
    hyp_list = []
    for hyp in prev_hyp_list
      for append_me in @token_atom hyp.b
        hyp_add = hyp.clone()
        hyp_add.push {
          token : append_me
          label : 'TODO_tok_pos'
        }
        hyp_list.push hyp_add
    
    prev_hyp_list = hyp_list
    hyp_list = []
    for hyp in prev_hyp_list
      for append_me in @token_plus hyp.b
        hyp_add = hyp.clone()
        hyp_add.push {
          token : append_me
          label : 'TODO_tok_pos'
        }
        hyp_list.push hyp_add
    
    
    node_list = []
    for hyp in hyp_list
      
      node = new Node
      node.mx_hash.rule = "rule_Hatom_Hplus_ultEplus__u8"
      vv_list = []
      for obj in hyp.list
        # TODO obj.label -> hash_pos_idx
        node.value_array.push obj.token
        vv_list.push obj.token.value_view or obj.token.value
      node.value_view = vv_list.join ' '
      
      arg_list = node.value_array
      
      
      mx_hash_stub = node.mx_hash
      mx_hash_stub.hash_key = "stmt"
      mx_hash_stub["ult"] = "plus"
      
      node.a = node.value_array[0].a
      node.b = node.value_array.last().b
      
      node_list.push node
    
    return node_list
  
  # rule("stmt", "#atom #star")                       .mx("ult=star")
  rule_Hatom_Hstar_ultEstar__u9 : (start_pos, only_new = false)->
    group_idx = 1
    
    zero_hyp = new Hypothesis
    zero_hyp.ret_hash = "stmt"
    zero_hyp.a = start_pos
    zero_hyp.b = start_pos
    hyp_list = [zero_hyp.clone()]
    
    prev_hyp_list = hyp_list
    hyp_list = []
    for hyp in prev_hyp_list
      for append_me in @token_atom hyp.b
        hyp_add = hyp.clone()
        hyp_add.push {
          token : append_me
          label : 'TODO_tok_pos'
        }
        hyp_list.push hyp_add
    
    prev_hyp_list = hyp_list
    hyp_list = []
    for hyp in prev_hyp_list
      for append_me in @token_star hyp.b
        hyp_add = hyp.clone()
        hyp_add.push {
          token : append_me
          label : 'TODO_tok_pos'
        }
        hyp_list.push hyp_add
    
    
    node_list = []
    for hyp in hyp_list
      
      node = new Node
      node.mx_hash.rule = "rule_Hatom_Hstar_ultEstar__u9"
      vv_list = []
      for obj in hyp.list
        # TODO obj.label -> hash_pos_idx
        node.value_array.push obj.token
        vv_list.push obj.token.value_view or obj.token.value
      node.value_view = vv_list.join ' '
      
      arg_list = node.value_array
      
      
      mx_hash_stub = node.mx_hash
      mx_hash_stub.hash_key = "stmt"
      mx_hash_stub["ult"] = "star"
      
      node.a = node.value_array[0].a
      node.b = node.value_array.last().b
      
      node_list.push node
    
    return node_list
  
  # rule("stmt", "#expr")                             .mx("ult=pass")
  rule_Hexpr_ultEpass__u11 : (start_pos, only_new = false)->
    group_idx = 1
    
    zero_hyp = new Hypothesis
    zero_hyp.ret_hash = "stmt"
    zero_hyp.a = start_pos
    zero_hyp.b = start_pos
    hyp_list = [zero_hyp.clone()]
    
    prev_hyp_list = hyp_list
    hyp_list = []
    for hyp in prev_hyp_list
      for append_me in @token_expr hyp.b
        hyp_add = hyp.clone()
        hyp_add.push {
          token : append_me
          label : 'TODO_tok_pos'
        }
        hyp_list.push hyp_add
    
    
    node_list = []
    for hyp in hyp_list
      
      node = new Node
      node.mx_hash.rule = "rule_Hexpr_ultEpass__u11"
      vv_list = []
      for obj in hyp.list
        # TODO obj.label -> hash_pos_idx
        node.value_array.push obj.token
        vv_list.push obj.token.value_view or obj.token.value
      node.value_view = vv_list.join ' '
      
      arg_list = node.value_array
      
      
      mx_hash_stub = node.mx_hash
      mx_hash_stub.hash_key = "stmt"
      mx_hash_stub["ult"] = "pass"
      
      node.a = node.value_array[0].a
      node.b = node.value_array.last().b
      
      node_list.push node
    
    return node_list
  
  # rule("stmt", "#expr #stmt")                       .mx("ult=join")
  rule_Hexpr_Hstmt_ultEjoin__u12 : (start_pos, only_new = false)->
    group_idx = 1
    
    zero_hyp = new Hypothesis
    zero_hyp.ret_hash = "stmt"
    zero_hyp.a = start_pos
    zero_hyp.b = start_pos
    hyp_list = [zero_hyp.clone()]
    
    prev_hyp_list = hyp_list
    hyp_list = []
    for hyp in prev_hyp_list
      for append_me in @token_expr hyp.b
        hyp_add = hyp.clone()
        hyp_add.push {
          token : append_me
          label : 'TODO_tok_pos'
        }
        hyp_list.push hyp_add
    
    prev_hyp_list = hyp_list
    hyp_list = []
    for hyp in prev_hyp_list
      for append_me in @token_stmt hyp.b
        hyp_add = hyp.clone()
        hyp_add.push {
          token : append_me
          label : 'TODO_tok_pos'
        }
        hyp_list.push hyp_add
    
    
    node_list = []
    for hyp in hyp_list
      
      node = new Node
      node.mx_hash.rule = "rule_Hexpr_Hstmt_ultEjoin__u12"
      vv_list = []
      for obj in hyp.list
        # TODO obj.label -> hash_pos_idx
        node.value_array.push obj.token
        vv_list.push obj.token.value_view or obj.token.value
      node.value_view = vv_list.join ' '
      
      arg_list = node.value_array
      
      
      mx_hash_stub = node.mx_hash
      mx_hash_stub.hash_key = "stmt"
      mx_hash_stub["ult"] = "join"
      
      node.a = node.value_array[0].a
      node.b = node.value_array.last().b
      
      node_list.push node
    
    return node_list
  

# ###################################################################################################
parser = new module.Parser

@parse = (str)->
  tok_list = tokenizer.go str
  res_list = parser.go tok_list

# debug
@tokenizer = tokenizer
@parser = parser
